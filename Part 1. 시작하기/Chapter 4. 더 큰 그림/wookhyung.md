## 4.1 첫 번째 기둥: 스코프와 클로저

- 스코프는 양동이, 변수는 양동이에 넣을 구슬에 비유할 수 있다. 이때 언어 고유의 스코프 모델은 구슬과 같은 색을 가진 양동이를 찾도록 도와주는 규칙이다.
- 스코프 안에는 다른 스코프가 올 수 있다. 스코프가 중첩될 때 표현식이나 문은 해당 레벨의 스코프 혹은 더 높거나 바깥 레벨에 있는 변수에만 접근할 수 있고, 낮거나 안쪽 레벨 스코프에 있는 숨겨진 변수에는 접근할 수 없다.
    - 이를 렉시컬 스코프(어휘 스코프)라고 부른다.
- JS만의 독특한 특징 첫 번째는 호이스팅이다.
    - 특정 스코프 내에 선언한 변수가 선언된 위치와 상관없이 해당 스코프 시작 부분에서 선언한 것마냥 처리되어 호이스팅이란 이란이 붙었다.
- 두 번째 특징은 var를 사용해 선언한 변수는 해당 변수를 선언한 블록 위치와 상관없이 함수 기준으로 스코프가 만들어진다는 점이다.
- 클로저는 JS 같이 함수를 일급값으로 취급하는 언어에서 렉시컬 스코프 모델을 사용하면 자연스레 나타나는 결과다.
    - 바깥 스코프에 있는 변수를 참조하는 함수가 있고, 이 함수가 변수를 통해 별개의 스코프에서 실행될 때, 함수는 함수가 정의된 스코프를 기준으로 변수를 참조한다. 이게 바로 클로저다.

## 4.2 두 번째 기둥: 프로토타입

- JS는 클래스를 통해 사전에 구조를 정의하지 않아도 직접적이고 명시적으로 객체를 만들 수 있는 몇 안 되는 언어 중 하나다.
- 과거 몇 년간 개발자들은 프로토타입을 사용해 프로토타입 상속이라 부르는 클래스 디자인 패턴을 구현해왔다. 그런데 ES6에서 class 키워드가 등장하면서 JS를 객체 지향/클래스 스타일로 개발하자는 움직임이 심화되었다.
- 객체는 객체로서 그대로 두고, 클래스 없이 프로토타입 체인을 통해 객체가 협력하도록 하는 전혀 다른 방식의 접근법도 있다.
    - 이 접근법을 작동 위임 패턴이라 한다. 필자는 코드 동작과 데이터 구조화하는 데 있어서 작동 위임 패턴이 클래스 상속보다 더 강력하다고 생각한다.

## 4.3 세 번째 기둥: 타입과 타입 강제 변환

- JS의 본질을 따른다면 정적 타입 도구 없이도 우리가 목표한 바를 달성할 수 있다.

## 4.4 JS의 본질 따르기

- JS로 작성한 프로그램을 다른 언어로 작성한 것처럼 바꾸는 것을 학습하는 것이 아니라, JS 고유의 방식을 배우고 습득하는 게 먼저다.
- 실제 작업 중인 프로그램을 JS다우면서도 실용적으로 만들어라.

## 4.5 학습 순서

- 1권 ‘시작하기’ → 2권 ‘스코프와 클로저’ → 3권 ‘객체와 클래스’ → 4권 ‘타입과 문법’ → 5권 ‘동기와 비동기’ → 6권 ‘ES.Next와 그 너머’
