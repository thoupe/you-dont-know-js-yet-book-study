## 3.1 이터레이션

- 이터레이터 패턴을 사용하면 데이터를 덩어리(chunk) 단위로 표준화된 방법을 사용해 각각 처리할 수 있다.
- 이터레이터 패턴의 이런 접근 방식은 데이터 전체를 한꺼번에 처리하기보다 데이터를 일정 단위로 쪼개고, 이 조각들을 차례대로 순회하며 점진적으로 처리하면 좀 더 범용적이고 유용할 거라는 아이디어에서 출발했다.
- 이터레이터 패턴의 핵심은 반복 작업으로 데이터를 처리할 때 표준화된 방법을 제공한다는 점이다.

### 3.1.1 이터레이터 소비하기

- ES6에서는 for … of 반복문 같은 새로운 문법과 API를 정의해 표준화된 방법으로 이터레이터 리절트 객체를 소비할 수 있도록 제공한다.
- 표현식 … 를 사용하면 이터레이터를 소비할 수 있다. … 은 대칭 형태인 전개 구문과 나머지 매개변수를 이용해 사용한다. 이때 전개 구문이 이터레이터를 소비하는 주체인 이터레이터 소비자이다.

### 3.1.2 이터러블

- 이터레이터 소비 프로토콜은 순회 가능한 값인 이터러블을 소비하는 기술적인 방법이라고 정의할 수 있다.
- 이터레이터 소비 프로토콜은 이터러블을 사용해 이터레이터 인스턴스를 생성하고, 생성한 이터레이터 인스턴스를 소비해 연산을 마무리한다.
- ES6에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료구조나 컬렉션을 이터러블로 정의한다.
- 표준화된 이터레이션 프로토콜을 준수하면 전반적인 코드 가도성과 이해도가 올라간다는 장점이 있다.

## 3.2 클로저

- 클로저란 함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에서 계속 접근할 수 있는 경우를 의미한다.
- 객체는 클로저가 되지 않지만, 함수는 자연스럽게 클로저가 된다.
- 클로저를 직접 보고 싶다면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행해야 한다.

## 3.3 this 키워드

- 함수는 스코프 말고도 자신이 어디까지 접근 가능한지를 결정하는 함수만의 특징을 갖는다.
- 이 특징은 실행 컨텍스트 개념으로 가장 잘 설명되며 함수는 this 키워드를 통해 실행 컨텍스트에 접근한다.
- 스코프는 정적이며 함수를 정의하는 순간, 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 의미한다. 반면 함수의 실행 컨텍스트는 동적이다. 실행 컨텍스트는 함수를 정의한 위치나 함수를 호출하는 위치와 상관없이 함수의 호출 방식에 따라 결정된다.
- 즉, this는 함수의 정의에 종속되어 결정되는 변치 않는 특성이 아니라, 함수를 호출할 때마다 결정되는 동적인 특성이다.

## 3.4 프로토타입

- 프로토타입은 객체, 구체적으로 프로퍼티에 접근할 때 일어나는 동작과 관련된 특징이다.
- 프로토타입을 통해 연결된 일련의 객체는 프로토타입 체인이라고 부른다.

### 3.4.1 객체 연결 장치

- 객체 프로토타입 연결 장치를 직접 정의하고 싶을 때는 `Object.create()`를 사용해 객체를 만들면 된다.

### 3.4.2 this 다시 보기

- 함수 호출 시 this가 동적으로 컨텍스트를 가져오는 중요한 이유는 프로토타입 체인을 통해 위임한 객체에 있는 메서드를 호출할 때, this가 코드 작성자의 의도대로 되게끔 하는 데 있다.
