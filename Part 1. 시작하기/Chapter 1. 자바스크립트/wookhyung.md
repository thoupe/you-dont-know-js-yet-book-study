## 1.1 책에 대하여

- 

## 1.2 자바스크립트 이름의 유래

- 이 언어는 자바 개발자들에게 어필하기 위해 만들어졌고, 당시 ‘스크립트’ 라는 단어가 ‘가벼운 프로그램’이라는 뜻으로 유행했기 때문이다. (개발자들에게 어필하기 위한 마케팅 목적)
- 오라클이 소유한 상표가 아닌 TC39에서 지정하고 ECMA 표준 기구에 의해 공식화된 명칭으로 JS를 부르면 ECMAScript가 됩니다.

## 1.3 명세서

- TC39는 JS를 관리하는 기술 운영 위원회(TSC)로, JS의 공식 명세를 관리합니다. 이 명세서에 JS 문법과 작동 방식이 정의됩니다.
- TC39에서 모든 제안은 다섯 단계로 이루어진 절차를 거치며, TC39 회원이 아닌 누군가가 비공식 수단을 통해 아이디어를 제안하고 TC39 위원 중 한 명이 이런 ‘0단계 이전’의 아이디어가 가치 있다고 생각해 옹호하면 제안이 ‘0단계’로 올라간다.
- TC39와 ECMA에 의해 유지되는 공식적인 표준 JS는 단 하나뿐이다.
- 모든 주요 브라우저, 디바이스 제조사는 단 하나뿐인 명세서를 기준으로 JS 구현체를 만듭니다.
    - 덕분에 하나의 JS만 배워도 되고, 어디서나 동일한 JS를 이용할 수 있다.

### 1.3.1 JS를 지배하는 웹

- 브라우저 제조사들은 명세서 개정안을 반영했을 때 기존에 잘 보이던 콘텐츠가 깨지는 경우, 명세서 개정안을 자사 엔진에 반영하지 않겠다는 결정을 내린다.
- 불일치가 발생하면 TC39 위원회는 종종 기존 결정을 철회하고 명세서를 웹에 맞춥니다.
- 불일치로 인한 문제가 발생할 수 있다고 생각할 수 있지만,  ECMAScript 명세서와 실제 웹에서 돌아가는 JS의 차이가 명세서 페이지의 부록에 상세히 기록되어 있다.

### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

- 브라우저 엔진, Node.js 등과 같이 JS가 실행되는 환경은 전역 스코프에 API를 추가해 자체적으로 사용할 수 있는 기능을 제공한다. ex. `alert()` 함수
    - `fetch()`, `getCurrentLocation()`, `getUserMedia()` 는 JS처럼 보이지만 실제로는 웹에서만 지원되는 API다.
    - Node.js 환경에서 역시 `fs.write()` 같은 다양한 빌트인 모듈을 제공한다.
    - `console.*` 메서드는 명세서에는 없지만 광범위하게 사용되어 거의 모든 환경에서 이 메서드를 지원합니다.

### 1.3.3 모든 코드가 JS인 것은 아닙니다

- 개발자 도구는 명세서에 정의된 명세를 정확히 재현하기 위해 만든 도구가 아니다.
- 개발자 편의를 위해 만든 도구들은 브라우저마다 동작도 다르고 가끔 바뀐다.

## 1.4 JS의 다양한 얼굴

- JS는 다중 패러다임 언어라 절차적, 객체 지향, 함수형 스타일 코드를 모두 작성할 수 있다.

## 1.5 하위 호환성과 상위 호환성

- JS를 지탱하는 기본 원칙 중 하나는 하위 호환성 보장이다.
- HTML과 CSS는 JS와 달리 상위 호환성을 보장하지만 하위 호환성을 보장하지는 않는다.

### 1.5.1 간극을 줄이기 위한 노력

- JS는 상위 호환성을 보장하기 않기에 아주 오래된 엔진에서는 유효한 문법으로 작성한 코드가 돌아가지 않을 가능성이 있다.
- 상위 호환성으로 인해 발생하는 문제 대부분은 트랜스파일러를 사용하면 해결된다.

### 1.5.2 간극을 메우기 위한 방법 찾기

- 상위 호환성 문제가 새로운 문법이 아닌 근래에 추가되었지만, 아직 지원하지 않는 API 메서드 때문에 발생했다면, 메서드 정의를 추가해 이미 이 메서드가 오래된 환경에도 있었던 것처럼 해주는 방법이 가장 일반적인 해결책이다.
    - 이런 패턴을 폴리필이라고 한다.

## 1.6 인터프리터 이해하기

- JS가 인터프리터 언어인지 컴파일러 언어인지에 대한 논쟁은 오랫동안 이어져왔다.
- JS 엔진은 파싱 이후 생성된 코드를 다양한 방법으로 실행 전에 그때그때 (JIT) 처리 및 최적화한다.
- 필자는 JS가 컴파일 언어라고 생각한다. 개발자가 실수를 하더라도 코드 실행 전에 정적 오류를 미리 발견할 수 있다는 특징이 있기 때문이다.

### 1.6.1 웹어셈블리

- Wasm은 JS가 주력이 아닌 개발자도 JS 엔진에서 돌아가는 코드를 쉽게 작성할 수 있는 데 그 목적이 있다.
- Wasm을 사용하면 다른 언어에서 사용하는 기능, 특히 트랜스파일을 거치는 프로그램 전용으로 설게된 기능을 JS에도 추가해야 한다는 압박이 줄어든다.

## 1.7 엄격 모드

- 엄격 모드는 JS 엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 해주는 최고의 ‘안내 가이드 역할을 하는 모드’이다.
- 대부분 초기 오류의 형태를 띠는데, 구문 오류는 아니지만 코드 실행 전 컴파일 단계에서 잡아낼 수 있는 오류를 의미한다.
