## 2.1 파일은 프로그램입니다

- JS에서는 파일 하나는 제3의 작고 독립적인 프로그램(파일)과 협력해 프로그램 전체를 작동시키는 고유한 작은 프로그램이다.

## 2.2 값

- JS에서 값은 크게 원시 타입과 객체 타입으로 분류된다.
- 백틱은 보간 표현식 없이 사용할 수 있지만 만들어진 목적과 부합하지 않으므로 권장하지 않는다.

### 2.2.1 배열과 객체

- 배열은 특수한 유형의 객체인데, 객체 내 정렬된 데이터는 숫자 인덱스가 매겨진다.
- 객체는 배열보다 좀 더 일반적인 데이터 타입으로, 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션이다.

### 2.2.2 값의 타입

- `typeof` 연산자를 사용해 원시 타입 값과 객체 타입 값을 구분합니다.

## 2.3 변수 선언과 사용

- 변수를 사용하려면 변수 선언(생성)이 선행되어야 한다. 식별자라고도 부르는 변수는 다양한 문법으로 선언할 수 있는데, 문법마다 작동 방식이 다르다.

## 2.4 함수

- JS로 개발할 때 함수보다 좀 더 포괄적인 개념인 ‘프로시저’를 프로그램에 녹여내기 위해 심사숙고하며 함수를 작성해야 한다.
    - 여기서 프로시저는 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음을 의미한다.
- JS에서 함수는 할당 가능하고 어디든 전달 가능한 값이라는 특징은 매우 중요하다. JS에서 함수는 객체의 한 종류이다. 함수형 프로그래밍 패러다임을 지원하는 언어에서는 함수를 값으로 취급하는게 필수다.

## 2.5 비교

### 2.5.1 같음에 대한 고찰

- 일치 비교와 동등 비교의 차이를 알아야 한다.
- === 연산자만으로는 아주 정확하게 비교를 할 수 없다.
- 일치 비교는 값의 본질이나 내용을 비교한다고 볼 수 있다.
    - ex. 42 === 42
    - 그러나 비교 대상이 객체인 경우에는 구조적 일치를 비교하게 된다.
    - JS에서는 객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않고, 대신 독자성 일치를 비교한다.

### 2.5.2 강제 변환

- 강제 변한은 한 타입의 값이 다른 타입의 값으로 변하는 걸 의미한다.
- == 연산자는 비교 이전에 강제로 타입을 맞추는 작업을 수행한다는 점에서 === 연산자와 차이가 있다.
- 필자는 == 연산자를  느슨한 동등 비교 안산자가 아닌 강제 변환 동등 비교 연산자라고 설명하는 게 적합하다고 생각한다.

## 2. 6 코드 구조화 패턴

### 2.6.1 클래스

- 클래스는 사용자가 정의한 데이터 ‘타입’으로 데이터와 이 데이터를 조작하는 동작이 들어간다.
- 클래스 없이도 만들 수 있지만, 클래스가 없다면 체계적이지 않고 가독성이 떨어지며, 유지 보수하기 어려운 프로그램이 될 가능성이 높다.
- 상속받은 메서드와 새롭게 정의한 메서드의 이름이 동일하고 공존할 수 있는 걸 다형성이라고 한다.

### 2.6.2 모듈

- 모듈 패턴은 클래스와 마찬가지로 논리적 단위 기준으로 데이터와 행동을 그룹화하는 데 그 목적이 있다.
- 클래식 모듈의 주요 특징은 최소한 한 번 이상 실행되는 외부 함수이다.
    - 클래식 모듈 인스턴스에 있는 함수를 모듈 팩토리라고 설명하기도 한다.
- ES6에서 도입된 ES 모듈(ESM)은 앞서 배운 클래식 모듈과 동일한 취지를 갖는 문법으로, AMD와 UMD, CommonJS의 주요 변형과 그 용례를 고려해 만들어졌다.
    - ES 모듈에는 모듈을 정의하는 래핑 함수가 없다.
    - ES 모듈을 사용할 때 모듈 API와 직접 상호작용하지 않는다.
    - ES 모듈을 인스턴스화하지 않아도 import 키워드를 사용해 가져오기만 한다면 단일 인스턴스처럼 사용할 수 있다.
        - 이러한 관점에서 ES 모듈은 사실상 싱글턴이라고 할 수 있다.
