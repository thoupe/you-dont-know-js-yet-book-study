## 2.1 구슬과 양동이

- 구슬은 프로그램 내 변수이고, 양동이는 스코프(함수 혹은 블록)이다.
- 변수의 스코프는 변수가 어디에서 선언되었는지에 따라 달라지기 때문에 각 구슬의 색은 원래 구슬이 어디에서 생성되었는지에 따라 결정된다.
- JS 엔진은 컴파일 중에 프로그램을 처리하기 때문에 변수가 선언된 곳을 찾는다는 건 “내가 지금 속한 스코프(버블 또는 양동이)가 무슨 색이야?” 라고 질문하는 것과 같습니다.

## 2.2 JS 엔진 구성원 간의 대화

- 구성원들의 역할은 다음과 같다.
    - 엔진: 컴파일레이션을 시작부터 끝까지 책임지고 JS로 만든 프로그램을 실행함
    - 컴파일러: 엔진의 친구로, 파싱과 코드 생성 과정에서 일어나는 모든 잡일을 담당함
    - 스코프 매니저: 엔진의 또 다른 친구로, 선언된 모든 변수와 식별자를 담은 탐색용 목록을 작성하고 유지 보수함. 여기에 더해 코드 실행 시, 선언된 변수와 식별자 접근 관련 규칙을 강제함
- `var students =  [ … ]` 같은 문은 다음과 같이 처리된다.
    1. 컴파일러가 스코프 변수 선언을 준비한다(현재 스코프에서 스코프 변수가 선언되어 있지 않은 경우).
    2. 엔진은 엔진이 실행되는 동안, 문에서 할당 부분을 처리하기 위해 스코프 매니저에게 변수를 찾아달라고 부탁하고 변수를 undefined로 초기화해 사용할 준비를 한다. 그 이후 변수에 배열을 할당한다.

## 2.3 중첩 스코프

- 모든 스코프는 한 번이든 여러 번이든 실행될 때마다 스코프에 해당하는 스코프 매니저 인스턴스를 갖게 된다. 그리고 스코프가 실행될 때마다 자동으로 해당 스코프 내 모든 식별자가 스코프에 등록된다.
- 렉시컬 스코프의 중요한 특징 중 하나는 현재 스코프에서 식별자 참조를 찾을 수 없을 때 해당 스코프를 감싸는 바깥 스코프에서 식별자 참조를 찾는다는 것이다. 이런 프로세스는 원하는 식별자 참조를 찾거나 더 이상 찾을 만한 스코프가 없을 때까지 계속된다.

### 2.3.1 탐색이 실패할 경우

- 엔진이 탐색 범위를 확장해가며 모든 렉시컬 스코프를 뒤졌는데도 원하는 식별자를 찾지 못한 경우에는 오류 발생 상태가 조성된다.
- **undefined에 관한 혼란**
    - 변수가 소스 역할을 할 때 식별자를 찾지 못하면 해당 변수는 선언되지 않은(알 수 없는 혹은 누락된) 변수로 간주되어 ReferenceError가 발생한다. (ex. Reference Error: XYZ is not defined.)
    - undefined는 변수는 발견되었는데(선언은 되어 있는데) 해당 시점에 값이 없는 경우를 의미한다.
- 전역 변수의 갑작스러운 등장
    - 엄격 모드를 사용하지 않을 경우 선언되지 않은 변수에 값을 할당하려는 실수가 발생할 수 있다.

### 2.3.2 스코프 건물

- 건물은 프로그램의 중첩 스코프 모음이다. 1층은 현재 실행 중인 스코프를 나타내고, 꼭대기 층은 전역 스코프를 나타낸다.
- 현재 층에서 원하는 변수 참조를 찾지 못하면 다음 층(바깥 스코프)로 가서 변수 참조를 찾는다. 꼭대기층(전역 스코프)에 도달하면 탐색이 중단된다.
