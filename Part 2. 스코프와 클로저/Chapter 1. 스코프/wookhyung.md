## 1.1 책에 대하여

- JS는 스크립트 언어로 분류되지만, 실제 JS는 실행 전 별도의 단계에서 파싱, 컴파일이 일어난다.
- JS에서 함수는 일급값(first-class value)이기 때문에 변수에 할당할 수 있고, 다른 곳으로 넘기는 것도 가능하다.
- 다른 곳으로 넘긴 함수 내에서 외부 변수를 사용하는 경우, 해당 변수는 어딘가에 접근해야 하므로 JS에서는 함수를 프로그램 내 어디에서 실행했는지와는 상관없이 함수를 정의할 때 결정된 스코프를 유지한다. 이를 클로저라고 한다.

## 1.2 컴파일 vs 인터프리트

- 컴파일레이션은 텍스트 형식으로 작성한 코드를 처리해서 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 일련의 과정이다.
- 인터프리테이션은 개발자가 작성한 프로그램을 기계가 해석할 수 있는 명령으로 변환한다는 점에서 컴파일과 유사하지만, 처리 방식이 다르다.
    - 컴파일레이션은 프로그램을 한 번에 처리하는 반면 인터프리테이션은 소스 코드를 한 줄씩 변환한다는 데 차이가 있다.

## 1.3 코드 컴파일

- 스코프는 중로 컴파일 중에 결정된다. 따라서 스코프를 정복하려면 컴파일레이션과 실행이 어떻게 연관되는지 이해하는 게 중요하다.
- 고전 컴파일러 이론에서는 프로그램이 컴파일러의 다음 세 가지 주요 단계를 거치 처리된다고 정의한다.
    1. 토크나이징(tokenizing)/렉싱(lexing): 문자열을 토큰이라 불리는 의미 있는 조각으로 쪼갠다.
        1. 토크나이즈와 렉싱의 차이는 토큰을 무상태 방식으로 인식하는지와 상태 유지 방식으로 인식하는지에 있다.
    2. 파싱: 토큰 배열을 프로그램 문법 구조를 반영하는 중첩 원소 기반의 트리인 AST(추상 구문 트리)로 바꾼다.
    3. 코드 생성: AST를 컴퓨터가 실행 가능한 코드로 변환한다. 코드 생성 단계는 언어 혹은 목표하는 플랫폼 등에 따라 크게 달라진다.

### 1.3.1 필수 두 단계

- 파싱과 컴파일이 먼저 일어나고 그 다음에 실행이 된다.
- ECMA 명세서에 ‘컴파일레이션이 반드시 필요하다’고 적혀 있지는 않지만 선 컴파일 후 실행(complie-then-execute) 접근 방식을 취하지 않으면 명세서 요구하는 동작을 충족할 수 없다.
- 선 컴파일 후 실행 접근 방식을 입증할 수 있는 JS만의 세 가지 특징으로는 구문 오류, 초기 오류, 호이스팅이 있다.

## 1.4 컴파일러체

- 선언을 제외하고 프로그램 내 모든 변수의 식별자는 할당의 타깃이나 값의 소스, 둘 중 하나의 역할을 한다.
- 변수 처리를 위해서 JS 엔진은 변수가 나타날 때마다 가장 먼저 변수 각각에 타깃과 소스라는 이름표를 붙인다.

## 1.5 런타임에 스코프 변경하기

- 스코프는 프로그램이 컴파일될 때, 결정되고 런타임 환경에는 영향을 받지 않는다.
- 그런데 비엄격 모드에서는 런타임에도 프로그램의 스코프를 수정할 수 있는 방법 두 가지가 있다. 하지만 두 방법 모두 사용해서는 안된다.
    1. `eval()` 함수
        1. `eval()` 은 컴파일과 실행의 대상이 되는 문자열 형태의 소스 코드를 받는데 이 소스 코드는 런타임에 컴파일, 실행된다.
        2. `var` 나 `function` 선언이 있는 경우, 이 선언들은 `eval()` 이 실행 중인 스코프를 변경한다.
    2. `with` 
        1. `with` 는 특정 객체의 스코프를 지역 스코프로 동적으로 변환한다. 이렇게 스코프가 변환되면 새로운 지역 스코프에서는 객체의 프로퍼티가 식별자가 되기 때문에 객체를 통하지 않고 바로 사용할 수 있다.

## 1.6 렉시컬 스코프

- 컴파일 타임에 결정되는 스코프를 렉시컬 스코프(어휘 스코프)라고 한다.
- 렉시컬 스코프의 핵심은 함수나 블록, 변수 선언의 스코프는 전적으로 코드 배치에 따라 제한된다는 점이다.
- 컴파일 중에는 스코프를 식별하기만 하고 실제 각 스코프를 실행해야만 하는 런타임 전까지는 스코프가 생성되지 않는다.
